# -*- mode: python; coding: utf-8; -*-

# simuPOPtest2.py - Simulation!

# Copyright (C) 2011 Seiji Kumagai <seiji.kumagai@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import argparse, sys

import simuOpt
simuOpt.setOptions(
    quiet = True,
    alleleType = 'long',
    optimized = False)
import simuPOP as sim

# Temporaly measure
from simulation import AUTOSOME, CHROMOSOME_X, CHROMOSOME_Y, MITOCHONDRIA
from simulation import get_genes, rename_alleles
from simulation import genealogies
from simulation.exception import SizeError
from simulation.evol_operator.selector import SelectorProvider
from simulation.evol_operator.geno_initiator import InitGenotype
from simulation.evol_operator.dumper import Dumper
from simulation.evol_operator.genealogy_tracker import GenealogyTracker, init_genealogies



def run(args):
    """Run simulations with appropriate parameters.

    Arguments:
    args: Namespace object generated by argparse.
    """

    # Set model parameters
    factors = args.factor
    if factors is not None:
        factors.sort()
    pop_sizes = args.pop_sizes
    init_genealogies(sum(pop_sizes), [AUTOSOME,
                                      CHROMOSOME_X,
                                      CHROMOSOME_Y,
                                      MITOCHONDRIA])

    if factors is not None:
        # Neutral markers without incompatibility factors.
        len_factors = len(factors)
        if args.female_recombination is None or args.male_recombination is None:
            raise SizeError(len_factors, 0)
        else:
            female_recomb_rate = args.female_recombination
            male_recomb_rate = args.male_recombination
            if len(female_recomb_rate) != len_factors:
                raise SizeError(len_factors, len(female_recomb_rate))
            if len(male_recomb_rate) != len_factors:
                raise SizeError(len_factors, len(male_recomb_rate))
    female_mig_rates = args.female_migration
    male_mig_rates = args.male_migration
    sex_ratio = args.sex_ratio
    if args.male_selection is None:
        female_sel = None
        male_sel = None
    else:
        female_sel = args.female_selection
        male_sel = args.male_selection

        if len_factors != len(female_sel):
            raise SizeError(len_factors, len(female_sel))
        if len_factors != len(male_sel):
            raise SizeError(len_factors, len(male_sel))


    # Define basic mode of genetic transmission as the standard
    # diploid model.
    matingOps = [sim.MendelianGenoTransmitter(),
                 sim.MitochondrialGenoTransmitter(chroms = 3)]

    # Define locations and rates of recombination.  Recombination only
    # occurs between a neutral marker locus and an incompatibility
    # factor.  In other words, there is no intro-locus recombination.
    # Moreover, choromosome Y and mitochondria do not recombine.
    for c in [AUTOSOME, CHROMOSOME_X]:
        if factors is not None and c in factors:
            index = factors.index(c)
            matingOps.append(
                sim.Recombinator(rates = male_recomb_rate[index],
                                 # No neutral mutation to consider
                                 loci = 0,
                                 subPops = [(0, 0), (1, 0)])
                )
            matingOps.append(
                sim.Recombinator(rates = female_recomb_rate[index],
                                 # No neutral mutation to consider
                                 loci = 0,
                                 subPops =[(0, 1), (1, 1)])
                )

    # Specify sex-ratio of offsprings.  Because the sequence, from
    # which sex of offspring is determined, is ordered such that first
    # all males offspring then all female offspring, it is important
    # to realize that the correct sex-ratio is only achieved when
    # local population size is multple of the sequence.
    if sex_ratio == 50:
        sex_mode = [sim.MALE, sim.FEMALE]
    elif not sex_ratio % 25:
        times = sex_ratio / 25
        sex_mode = [sim.MALE] * times + [sim.FEMALE] * (4 - times)
    elif not sex_ratio % 20:
        times = sex_ratio / 20
        sex_mode = [sim.MALE] * times + [sim.FEMALE] * (5 - times)
    elif not sex_ratio % 10:
        times = sex_ratio / 10
        sex_mode = [sim.MALE] * times + [sim.FEMALE] * (10 - times)
    elif not sex_ratio % 5:
        times = sex_ratio / 5
        sex_mode = [sim.MALE] * times + [sim.FEMALE] * (20 - times)
    elif not sex_ratio % 2:
        times = sex_ratio / 2
        sex_mode = [sim.MALE] * times + [sim.FEMALE] * (50 - times)
    else:
        sex_mode = [sim.MALE] * sex_ratio + [sim.FEMALE] * (100 - sex_ratio)

    # Test if population size is multiple of the sequence of
    # offspring.  If not, terminate the simulation as there is no way
    # to gurantee the correct sex-ratio.
    if False in [not p % len(sex_mode) for p in pop_sizes]:
        raise SizeError(p, len(sex_mode))

    sex_mode = tuple([sim.GLOBAL_SEQUENCE_OF_SEX] + sex_mode)

    # If seed is given, we perform only as much number of runs as the
    # number of supplied seed.  This is intended to generate
    # reproducible results.

    # A variable indicating if seed is supplied via command line
    seed_provided = False
    if args.seed is not None:
        reps = args.seed
        seed_provided = True
    else:
        reps = range(args.reps)
    print('Pop Size: 0|{} 1|{}, Sex Ratio: F|{} M|{}'.format(
        pop_sizes[0], pop_sizes[1], 100 - sex_ratio, sex_ratio),
          end = '')
    print(', Mig Rate: F.M12|{} F.M21|{} M.M12|{} M.21|{}'.format(
        female_mig_rates[0], female_mig_rates[1],
        male_mig_rates[0], male_mig_rates[1]),
          end = '')
    if factors is not None:
        print(', Factors: {}, Sel Coeff: F|{} M|{}'.format(
            factors, female_sel, male_sel),
              end = '')
        print(', Recomb Rate: F|{} M|{}'.format(
            female_recomb_rate, male_recomb_rate))
    else:
        print('')

    # Let simulation run!
    for r in reps:
        # Define population and genetic structure.
        pop = sim.Population(size = pop_sizes,
                             # 1st locus is the tag to identify which
                             # (ultimate) parent the 2nd locus was
                             # descendent from.
                             # The second locus is the actual locus.
                             # loci = [2] * 4,
                             # Right now, in order to speed up
                             # simulations, mutations are not invoked
                             # during simulation.
                             loci = [1] * 4,
                             # lociNames = ['marker.a', 'marker.a_',
                             #              'marker.X', 'marker.X_',
                             #              'marker.Y', 'marker.Y_',
                             #              'marker.mt', 'marker.mt_']
                             chromTypes=[sim.AUTOSOME,
                                         sim.CHROMOSOME_X,
                                         sim.CHROMOSOME_Y,
                                         sim.CUSTOMIZED],
                             infoFields = ['migrate_to',
                                           'fitness'])
        # Add incompatibility factors on appropriate chromosomes.
        # Placing more than one factors on one chromosome is currently
        # not supported.
        if factors is not None:
            factor_pos = [2] * len(factors)
            for f in factors:
                # pop.addLoci(chrom = f, pos = 3)
                # neutral loci are at position 1.
                pop.addLoci(chrom = f, pos = 2)

            sel = SelectorProvider(pop, factors, factor_pos,
                                   female_sel, male_sel)

        # Sex-specific processes (selection and migration) require
        # setting up virtual populations based-on sex.
        pop.setVirtualSplitter(sim.SexSplitter())


        # Set up simulator
        s = sim.Simulator(pop)
        if seed_provided:
            seed = r
        else:
            seed = sim.getRNG().randInt(2**31)
        sim.getRNG().set(name = 'mt19937', seed = seed)

        preOps = [sim.Migrator(rate = [[0, male_mig_rates[0]],
                                           [male_mig_rates[1], 0]],
                                   mode = sim.BY_PROBABILITY,
                                   subPops = [(0, 0), (1, 0)]),
                      sim.Migrator(rate = [[0, female_mig_rates[0]],
                                           [female_mig_rates[1], 0]],
                                   mode = sim.BY_PROBABILITY,
                                   subPops = [(0, 1), (1, 1)])]
        if 'sel' in locals():
            preOps += sel.setSelector()

        print("<<{}>>".format(sim.getRNG().seed()))
        s.evolve(
            initOps = [sim.InitSex(sex = [sim.MALE, sim.FEMALE],
                                   subPops = 0),
                       sim.InitSex(sex = [sim.MALE, sim.FEMALE],
                                   subPops = 1),
                       InitGenotype(factors = factors, mutation = False)],
            preOps = preOps,

            matingScheme = sim.RandomMating(
                ops = matingOps,
                subPopSize = pop_sizes,
                sexMode = sex_mode),
            postOps = [
                GenealogyTracker([0] * 4,
                                 [AUTOSOME,
                                  CHROMOSOME_X,
                                  CHROMOSOME_Y,
                                  MITOCHONDRIA]),
                InitGenotype(factors = factors, mutation = False),
                ])

def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description = \
        'Run population genetics simulation to investigate introgression',
        prog = 'simuPOPtest2.py')
    parser.add_argument('pop_sizes',
                        nargs = 2,
                        type = int,
                        metavar = ('POP_SIZE_1', 'POP_SIZE_2'))
    parser.add_argument('-f', '--factor',
                        type = int,
                        nargs = '+')
    parser.add_argument('--male_selection', '--sM',
                        nargs = '+',
                        metavar = ('MALE_SEL_COEFF'),
                        type = float)
    parser.add_argument('--female_selection', '--sF',
                        nargs = '+',
                        metavar = ('FEMALE_SEL_COEFF'),
                        type = float)
    parser.add_argument('--male_migration', '--mM',
                        nargs = 2,
                        type = float,
                        metavar = ('M12', 'M21'),
                        default = [0.01, 0.01])
    parser.add_argument('--female_migration', '--mF',
                        nargs = 2,
                        type = float,
                        metavar = ('M12', 'M21'),
                        default = [0.01, 0.01])
    parser.add_argument('--female_recombination', '--rF',
                        nargs = '+',
                        type = float,
                        metavar = 'FEMALE_REC_RATE')
    parser.add_argument('--male_recombination', '--rM',
                        nargs = '+',
                        type = float,
                        metavar = 'MALE_REC_RATE')
    parser.add_argument('--sex_ratio',
                        type = int,
                        metavar = '%_MALE',
                        default = 50)
    parser.add_argument('--sample_size',
                        type = int,
                        default = 50)
    parser.add_argument('--version',
                        action='version',
                        version='%(prog)s 0.1')

    # --seed and --reps are mutually exclusive.
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--seed',
                       type = int,
                       nargs = '*')
    group.add_argument('--reps',
                       type = int,
                       default = 1)


    return parser.parse_args()

if __name__ == '__main__':

    args = parse_args()
    # print(args)

    # Run simulations under the infinite site model
    run(args)
